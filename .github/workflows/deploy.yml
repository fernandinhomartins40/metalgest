name: Deploy to Hostinger VPS

on:
  push:
    branches:
      - main

jobs:
  port-check:
    name: Check for Available Port
    runs-on: ubuntu-latest
    outputs:
      APP_PORT: ${{ steps.get_port.outputs.APP_PORT }}

    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Get available port from VPS
        id: get_port
        run: |
          APP_PORT=$(sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no root@82.25.69.57 '
            # Function to check if port is available
            check_port() {
              local port=$1
              # Check if port is in use (listening)
              if netstat -tuln | grep -q ":$port "; then
                return 1  # Port is in use
              fi
              # Try to bind to port to double-check availability
              if timeout 2 bash -c "</dev/tcp/127.0.0.1/$port" 2>/dev/null; then
                return 1  # Port is in use
              fi
              return 0  # Port is available
            }
            
            # Search for available port in range 3000-9999
            for port in {3000..9999}; do
              if check_port $port; then
                echo $port
                exit 0
              fi
            done
            
            # If no port found in range, error
            echo "ERROR: No available ports found in range 3000-9999" >&2
            exit 1
          ')
          echo "Found available port: $APP_PORT"
          echo "APP_PORT=$APP_PORT" >> $GITHUB_OUTPUT

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: port-check
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build Frontend
        run: |
          npm install
          npm run build

      - name: Build Backend
        run: |
          cd backend
          npm install
          npm run build

      - name: Upload Frontend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist

      - name: Upload Backend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: backend/dist

  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: [port-check, build]
    steps:
      - name: Download Frontend Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-dist
          path: backend/dist

      - name: Transfer files to VPS
        uses: appleboy/scp-action@master
        with:
          host: 82.25.69.57
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          source: "Dockerfile,docker-compose.yml,frontend/dist/*,backend/dist/*"
          target: "/var/www/metalgest"

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: 82.25.69.57
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          script: |
            cd /var/www/metalgest
            
            # Create environment file
            echo "# Backend Environment Variables" > .env
            echo "NODE_ENV=production" >> .env
            echo "PORT=${{ needs.port-check.outputs.APP_PORT }}" >> .env
            echo "API_VERSION=v1" >> .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> .env
            echo "DATABASE_URL=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@db:5432/${{ secrets.DB_NAME }}" >> .env
            echo "" >> .env
            echo "# Database Environment Variables" >> .env
            echo "POSTGRES_DB=${{ secrets.DB_NAME }}" >> .env
            echo "POSTGRES_USER=${{ secrets.DB_USER }}" >> .env
            echo "POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            
            # Update nginx configurations with actual port
            sed -i "s/PORT_PLACEHOLDER/${{ needs.port-check.outputs.APP_PORT }}/g" nginx.conf
            sed -i "s/PORT_PLACEHOLDER/${{ needs.port-check.outputs.APP_PORT }}/g" nginx-initial.conf
            
            # Stop any existing nginx service that might conflict
            systemctl stop nginx || true
            systemctl disable nginx || true
            
            # Kill any process using port 80 (except our container)
            lsof -ti:80 | grep -v docker | xargs kill -9 || true
            
            # Use initial nginx config for SSL generation
            cp nginx-initial.conf nginx.conf
            
            # Deploy with Docker Compose (initial setup)
            docker-compose down || true
            docker-compose up -d --build
            
            # Wait for nginx to be ready
            echo "Waiting for nginx to be ready..."
            sleep 10
            
            # Generate SSL certificate
            echo "Generating SSL certificate..."
            if docker-compose run --rm certbot; then
              echo "SSL certificate generated successfully"
              
              # Restore full nginx config with SSL
              cp nginx.conf.bak nginx.conf || git checkout nginx.conf
              sed -i "s/PORT_PLACEHOLDER/${{ needs.port-check.outputs.APP_PORT }}/g" nginx.conf
              
              # Reload nginx to use SSL certificate
              docker-compose exec nginx nginx -s reload
              
              # Setup SSL renewal cron job
              echo "Setting up SSL renewal cron job..."
              chmod +x ssl-renewal.sh
              (crontab -l 2>/dev/null; echo "0 2 * * * /var/www/metalgest/ssl-renewal.sh >> /var/log/ssl-renewal.log 2>&1") | crontab -
            else
              echo "SSL certificate generation failed, continuing with HTTP only"
            fi
            # Health check
            sleep 15
            docker ps
            
            # Check if nginx is running (HTTP - should redirect to HTTPS)
            echo "Testing HTTP to HTTPS redirect..."
            if ! curl -I -s http://localhost:80/api/v1/health | grep -q "301\|302"; then
              echo "HTTP to HTTPS redirect test failed, checking container logs..."
              docker logs metalgest_backend_1 --tail 50
              docker logs metalgest_nginx_1 --tail 50
            fi
            
            # Check HTTPS API health check
            echo "Testing HTTPS API health check..."
            if ! curl -f -k https://localhost:443/api/v1/health; then
              echo "HTTPS API health check failed, checking container logs..."
              docker logs metalgest_backend_1 --tail 50
              docker logs metalgest_nginx_1 --tail 50
              # Try HTTP fallback for debugging
              echo "Trying HTTP fallback..."
              curl -f http://localhost:80/api/v1/health || echo "HTTP also failed"
              exit 1
            fi
            
            # Check domain resolution with HTTPS
            echo "Testing HTTPS domain access..."
            if ! curl -f -k -H "Host: www.metalgest.com.br" https://localhost:443/api/v1/health; then
              echo "HTTPS domain access failed, checking nginx config..."
              docker exec metalgest_nginx_1 nginx -t
              docker logs metalgest_nginx_1 --tail 50
              exit 1
            fi
            
            echo "Deploy successful! API is running on port ${{ needs.port-check.outputs.APP_PORT }} with SSL enabled"
