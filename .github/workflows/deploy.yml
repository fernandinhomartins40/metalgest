name: Deploy to Hostinger VPS

on:
  push:
    branches:
      - main

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build Frontend
        run: |
          npm install
          npm run build

      - name: Build Backend
        run: |
          cd backend
          npm install
          npm run build

      - name: Upload Frontend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist

      - name: Upload Backend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: backend/dist

  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Download Frontend Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-dist
          path: backend/dist

      - name: Checkout code for deploy files
        uses: actions/checkout@v4
        with:
          path: source
          
      - name: Transfer files to VPS
        uses: appleboy/scp-action@master
        with:
          host: 82.25.69.57
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          source: "source/Dockerfile,source/docker-compose.yml,source/nginx.conf,source/nginx-initial.conf,source/ssl-renewal.sh,frontend/dist,backend/dist"
          target: "/var/www/metalgest"
          strip_components: 1

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: 82.25.69.57
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          script: |
            cd /var/www/metalgest
            
            # Create environment file with fixed port 3006
            echo "# Backend Environment Variables" > .env
            echo "NODE_ENV=production" >> .env
            echo "PORT=3006" >> .env
            echo "API_VERSION=v1" >> .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> .env
            echo "DATABASE_URL=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@db:5432/${{ secrets.DB_NAME }}" >> .env
            echo "" >> .env
            echo "# Database Environment Variables" >> .env
            echo "POSTGRES_DB=${{ secrets.DB_NAME }}" >> .env
            echo "POSTGRES_USER=${{ secrets.DB_USER }}" >> .env
            echo "POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            
            # Update nginx configurations with port 3006
            sed -i "s/PORT_PLACEHOLDER/3006/g" nginx.conf
            sed -i "s/PORT_PLACEHOLDER/3006/g" nginx-initial.conf
            
            # Stop any existing services that might conflict
            systemctl stop nginx || true
            systemctl disable nginx || true
            
            # Kill any process using ports 80 and 443
            lsof -ti:80 | xargs kill -9 || true
            lsof -ti:443 | xargs kill -9 || true
            
            # Stop any existing containers
            docker-compose down || true
            docker system prune -f || true
            
            # First, deploy with HTTP-only configuration
            echo "=== Phase 1: Deploy with HTTP-only configuration ==="
            cp nginx-initial.conf nginx.conf
            
            # Deploy with Docker Compose
            docker-compose up -d --build
            
            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 30
            
            # Check if containers are running
            echo "=== Container Status ==="
            docker-compose ps
            docker ps -a
            
            # Test HTTP connectivity first
            echo "=== Testing HTTP connectivity ==="
            for i in {1..10}; do
              if curl -f http://localhost:80/api/v1/health; then
                echo "HTTP API is working!"
                break
              fi
              echo "Attempt $i failed, retrying in 10s..."
              sleep 10
            done
            
            # Now try to generate SSL certificate
            echo "=== Phase 2: Generate SSL certificate ==="
            if docker run --rm -v "$(pwd)/certbot_certs:/etc/letsencrypt" -v "$(pwd)/certbot_www:/var/www/certbot" certbot/certbot:latest certonly --webroot --webroot-path=/var/www/certbot --email contato@metalgest.com.br --agree-tos --no-eff-email --keep-until-expiring --domains metalgest.com.br,www.metalgest.com.br; then
              echo "SSL certificate generated successfully"
              
              # Restore full nginx config with SSL
              git show HEAD:nginx.conf > nginx.conf || curl -s https://raw.githubusercontent.com/fernandinhomartins40/metalgest/main/nginx.conf > nginx.conf
              sed -i "s/PORT_PLACEHOLDER/3006/g" nginx.conf
              
              # Reload nginx to use SSL certificate
              docker-compose exec nginx nginx -s reload
              
              # Wait for SSL to be ready
              sleep 10
              
              # Setup SSL renewal cron job
              echo "Setting up SSL renewal cron job..."
              chmod +x ssl-renewal.sh
              (crontab -l 2>/dev/null; echo "0 2 * * * /var/www/metalgest/ssl-renewal.sh >> /var/log/ssl-renewal.log 2>&1") | crontab -
              
              echo "SSL configuration completed successfully"
            else
              echo "SSL certificate generation failed, continuing with HTTP only"
              echo "This is normal for first deployment - SSL will be configured in next deployment"
            fi
            # Final health check
            echo "=== Final Health Check ==="
            sleep 10
            docker-compose ps
            
            # Check if containers are running with proper names
            BACKEND_CONTAINER=$(docker-compose ps -q backend)
            NGINX_CONTAINER=$(docker-compose ps -q nginx)
            
            if [ -z "$BACKEND_CONTAINER" ] || [ -z "$NGINX_CONTAINER" ]; then
              echo "ERROR: Containers not found!"
              docker-compose ps
              docker ps -a
              exit 1
            fi
            
            # Test HTTP API health check
            echo "=== Testing HTTP API health check ==="
            if curl -f http://localhost:80/api/v1/health; then
              echo "HTTP API health check passed!"
            else
              echo "HTTP API health check failed, checking container logs..."
              docker logs $BACKEND_CONTAINER --tail 30
              docker logs $NGINX_CONTAINER --tail 30
              exit 1
            fi
            
            # Test HTTPS if SSL is configured
            if [ -f "certbot_certs/live/metalgest.com.br/fullchain.pem" ]; then
              echo "=== Testing HTTPS API health check ==="
              if curl -f -k https://localhost:443/api/v1/health; then
                echo "HTTPS API health check passed!"
                echo "Deploy successful! API is running on port 3006 with SSL enabled"
              else
                echo "HTTPS API health check failed, but HTTP works"
                echo "Deploy successful! API is running on port 3006 (HTTP only)"
              fi
            else
              echo "SSL certificate not found, running HTTP only"
              echo "Deploy successful! API is running on port 3006 (HTTP only)"
            fi
            
            # Test domain resolution
            echo "=== Testing domain access ==="
            if curl -f -H "Host: www.metalgest.com.br" http://localhost:80/api/v1/health; then
              echo "Domain access test passed!"
            else
              echo "Domain access test failed, but localhost works"
            fi
